//! Full system minidump parser for Windows kernel `.dump /f <dump name>`
//! commands

// _KPRCBs for each processor
// ((_KPRCB**)KdDebuggerDataBlock.KiProcessorBlock)[0]
// ((_KPRCB**)KdDebuggerDataBlock.KiProcessorBlock)[1]
// ((_KPRCB**)KdDebuggerDataBlock.KiProcessorBlock)[... NUM_PROCS]
//
// _KPCR found at (for each processor):
// ?? (_KPCR*)(((char**)KdDebuggerDataBlock.KiProcessorBlock)[... NUM_PROCS] - KdDebuggerDataBlock.OffsetPcrContainedPrcb)
//
// _CONTEXT found at (for each processor):
// ?? *(_CONTEXT**)(((char**)KdDebuggerDataBlock.KiProcessorBlock)[... NUM_PROCS] + KdDebuggerDataBlock.OffsetPrcbContext)
//
// _KSPECIAL_REGISTERS found at (for each processor):
// ?? ((_KPROCESSOR_STATE*)(((char**)KdDebuggerDataBlock.KiProcessorBlock)[3] + KdDebuggerDataBlock.OffsetPrcbProcStateSpecialReg))->SpecialRegisters

use core::convert::TryInto;
use alloc::collections::BTreeMap;

/// 64-bit AMD64 `_CONTEXT` structure from Windows
#[repr(C)]
pub struct Context64 {
    pub p1_home:       u64,
    pub p2_home:       u64,
    pub p3_home:       u64,
    pub p4_home:       u64,
    pub p5_home:       u64,
    pub p6_home:       u64,
    pub context_flags: u32,
    pub mxcsr:         u32,
    pub cs:            u16,
    pub ds:            u16,
    pub es:            u16,
    pub fs:            u16,
    pub gs:            u16,
    pub ss:            u16,
    pub eflags:        u32,
    pub dr0:           u64,
    pub dr1:           u64,
    pub dr2:           u64,
    pub dr3:           u64,
    pub dr6:           u64,
    pub dr7:           u64,
    pub rax:           u64,
    pub rcx:           u64,
    pub rdx:           u64,
    pub rbx:           u64,
    pub rsp:           u64,
    pub rbp:           u64,
    pub rsi:           u64,
    pub rdi:           u64,
    pub r8:            u64,
    pub r9:            u64,
    pub r10:           u64,
    pub r11:           u64,
    pub r12:           u64,
    pub r13:           u64,
    pub r14:           u64,
    pub r15:           u64,
    pub rip:           u64,
    pub fxsave:        [u8; 976],
}

/// A parsed minidump
pub struct MiniDump {
    /// Mapping for physical address bases into the (file offset, size)
    pub phys_ranges: BTreeMap<u64, (usize, usize)>,

    /// Address of `nt!KdDebuggerDataBlock`
    pub kd_debugger_data_block: u64,

    /// 64-bit context for the minidump
    pub context: Context64,
}

impl MiniDump {
    /// Parse a full Windows minidump generated by `.dump /f <dump name>` in
    /// WinDbg
    /// nt!PDUMP_HEADER64
    pub fn parse(buf: &[u8]) -> Option<Self> {
        assert!(core::mem::size_of::<Context64>() == 0x4d0,
            "Whoa, context size mismatch");

        if buf.get(..8) != Some(b"PAGEDU64") { return None; }

        // Get the number of physical memory regions in the full memory dump
        let num_runs = u32::from_le_bytes(
            buf.get(0x88..0x8c)?.try_into().ok()?);

        // Pages start at file offset 0x2000
        let mut page_offset = 0x2000usize;
        
        // Create some new physical ranges
        let mut phys_ranges = BTreeMap::new();

        // Get the context from the minidump
        let context = buf.get(0x348..0x348 + 3000)?;
        let context = unsafe {
            core::ptr::read_unaligned(context.as_ptr() as *const Context64)
        };

        // Go through each memory region in the full memory dump
        for rid in 0..num_runs as usize {
            // Get the corresponding physical memory region for this run
            let entry = buf.get(0x98 + rid * 0x10..0xa8 + rid * 0x10)?;

            // Get the base page and page count for this region
            let base_paddr =
                u64::from_le_bytes(entry[..8].try_into().ok()?)
                    .checked_mul(4096)?;
            let region_size: usize =
                u64::from_le_bytes(entry[8..].try_into().ok()?)
                    .try_into().ok()?;
            let region_size = region_size.checked_mul(4096)?;

            // Add this range to the minidump database
            phys_ranges.insert(base_paddr, (page_offset, region_size));

            // Advance the page offset
            page_offset = page_offset.checked_add(region_size)?;
        }

        // Make sure we consumed the entire file, if we did not, there's some
        // extra trailing data we did not expect
        assert!(page_offset == buf.len());

        Some(MiniDump {
            phys_ranges,
            context,
        })
    }
}

#[cfg(test)]
mod tests {
    use crate::*;

    #[test]
    fn it_works() {
        let minidump = std::fs::read("fulldump.dmp").unwrap();
        let minidump = MiniDump::parse(&minidump).unwrap();
        for (paddr, data) in minidump.phys_ranges.iter() {
            print!("{:016x} {:016x} {:02x?}\n",
                   paddr, paddr + (data.len() as u64 - 1),
                   &data[..8]);
        }
    }
}
