# Handles generation of the `handle_serialize_tuple_match` macro in
# `tuple_match.rs`

print("""/// AUTOGENERATED BY tuple_match_gen.py DO NOT MODIFY!
/// Handles matching of tuples based on the number of types they have. This
/// is kinda ugly but it seems to be required as there's no way to dynamically
/// construct an indentifer in macros. Since we can't make identifiers, we
/// cannot construct names for tuple variants which can be used during binding.""")

# Maximum number of tuple fields
NUM_TUPLES_ALLOWED = 64

NAMES = []

# Generate unique identifiers
for ii in range(NUM_TUPLES_ALLOWED+1):
    name = ""
    name += "abcdefghijklmnopqrstuvwxyz"[ii % 26]
    ii = int(ii / 26)
    name += "abcdefghijklmnopqrstuvwxyz"[ii % 26]
    NAMES.append(name)

# Generate matches for different depths of enums
print("#[macro_export]")
print("macro_rules! handle_serialize_tuple_match {")
for name_count in range(len(NAMES)):
    names = NAMES[:name_count]

    impl = "    ($self:ident, $count:expr, $buf:expr, $enumname:ident, $enumident:ident"
    for name in names:
        impl += ", $ty%s:ty" % name
    impl += ") => {\n"

    impl += "        if let $enumname::$enumident( "
    for name in names:
        impl += "%s," % name
    impl += ") = $self {\n"
    impl += "            Serialize::serialize($count, $buf)?;\n"

    for name in names:
        impl += "            Serialize::serialize(%s, $buf)?;\n" % name
    impl += "        }\n"
    impl += "    };"
    print(impl)
print("}")

